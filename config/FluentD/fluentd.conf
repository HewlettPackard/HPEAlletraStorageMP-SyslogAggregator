# =========================
# System / Fluentd own logs
# =========================
<system>
  <log>
    rotate_age 7
    rotate_size 104857600
  </log>
</system>

# =========================
# Source: Syslog over TLS
# =========================
<source>
  @type syslog
  @id in_syslog_tls_alletra
  tag alletra.syslog
  port 6514
  bind 0.0.0.0
  message_length_limit 8192
  <transport tls>
    cert_path           /etc/fluentd/certs/server.crt
    private_key_path    /etc/fluentd/certs/server.key
    private_key_passphrase "#{ENV['FLUENTD_TLS_KEY_PASSPHRASE']}"
    client_cert_auth    false
    version             TLS1_2
  </transport>
  <parse>
    @type regexp
    expression /^(?:<\d+>)?(?<event.ingested>[A-Z][a-z]{2}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+3PAR_(?<host.name>\S+)\s+(?:(?:MsgCode: 0x[0-9a-fA-F]+ )?)(?<event.provider>\S+)\s+(?<event.module>\S+)\s+(?<message>.+)$/
  </parse>
</source>

# ==========================================
# Filter unwanted
# ==========================================

<filter **>
  @type grep
  <or>
    <exclude>
      key message  
      pattern /\b127\.(\d{1,3}\.){2}\d{1,3}\b(:\d+)?/
    </exclude>

    <exclude>
      key event.provider
      pattern /(^cli_auth_info_sock$|^user_auth_succeded$)/i
    </exclude>
  </or>
</filter>

# ==========================================
# Tag based on event.dataset
# ==========================================

<match alletra.syslog.**>
  @type rewrite_tag_filter
  emit_mode record

# Audit logs
  <rule>
    key event.provider
    pattern /^audit_log_record$/i
    tag audit.log
  </rule>

# Authentication logs
  <rule>
    key event.provider
    pattern /^ssh_bad_password$/i
    tag ssh.login.fail
  </rule>
  <rule>
    key event.provider
    pattern /^cli_auth_success$/i
    tag cli.auth.success
  </rule>
  <rule>
    key event.provider
    pattern /^cli_auth_logout$/i
    tag cli.auth.logout
  </rule>
  <rule>
    key event.provider
    pattern /^wsapi_concurrent_login$/i
    tag wsapi.concurrent.login
  </rule>
  <rule>
    key event.provider
    pattern /^user_auth_succeeded$/i
    tag auth.user.succeeded
  </rule>
  <rule>
    key event.provider
    pattern /^user_locked$/i
    tag user.locked
  </rule>

# Ransomware monitoring
  <rule>
    key event.provider
    pattern /^sysmgr_rware_alert_snap$/i
    tag rware.snap
  </rule>
  <rule>
    key event.provider
    pattern /^rware_monitoring$/i
    tag rware.detect
  </rule>
  
# Root Activity
  <rule>
    key event.provider
    pattern /^root_activity_login$/i
    tag root.login
  </rule>
  <rule>
    key event.provider
    pattern /^root_activity_logout$/i
    tag root.logout
  </rule>
  <rule>
    key event.provider
    pattern /^root_activity_command$/i
    tag root.command
  </rule>

# CLI error
  <rule>
    key event.provider
    pattern /^cli_cmd_err_args$/i
    tag cli.error
  </rule>

</match>


# Second filter: catch-all for anything not retagged above
<match alletra.syslog.**>
  @type rewrite_tag_filter
  emit_mode record

  # If event.dataset exists but isn't one of the known values
  <rule>
    key event.provider
    pattern /^((?!user_locked|cli_cmd_err_args|user_auth_succeded|user_auth_succeeded|audit_log_record|wsapi_concurrent_login|cli_auth_info_sock|cli_auth_success|cli_auth_logout|rware_monitoring|sysmgr_rware_alert_snap|root_activity_login|root_activity_logout|root_activity_command).)*$/i
    tag other
  </rule>

  # If event.dataset is missing entirely, fall back to message presence
  <rule>
    key message
    pattern /.+/
    tag other
  </rule>
</match>


# =========================================================
# ROOT ACTIVITY
# =========================================================

<filter root.command>
  @type record_transformer
  enable_ruby true
  <record>
    # --- Extraction from the message ---
    # --- Layout expected: 
    # --- root[PID]: <src_ip> <src_port> <dst_ip> <dst_port>: /root: <command>
    source.ip             ${record["message"][/root\[\d+\]:\s+(\d{1,3}(?:\.\d{1,3}){3})\s+(\d+)\s+\d{1,3}(?:\.\d{1,3}){3}\s+\d+:\s+\/root:\s+(.+?)$/, 1]}
    source.port           ${record["message"][/root\[\d+\]:\s+(\d{1,3}(?:\.\d{1,3}){3})\s+(\d+)\s+\d{1,3}(?:\.\d{1,3}){3}\s+\d+:\s+\/root:\s+(.+?)$/, 2]}
    process.command_line  ${record["message"][/root\[\d+\]:\s+(\d{1,3}(?:\.\d{1,3}){3})\s+(\d+)\s+\d{1,3}(?:\.\d{1,3}){3}\s+\d+:\s+\/root:\s+(.+?)$/, 3]}
    user.name             root
    # --- ECS event classification ---
    event.kind      alert
    event.type      indicator
    event.category  threat
    event.action    root_activity
    event.severity  73
  </record>
</filter>

<filter root.login>
  @type record_transformer
  enable_ruby true
  <record>
    source.ip       ${record["message"][/from\s+(\d+\.\d+\.\d+\.\d+)/, 1]}
    user.name       root
    # --- ECS event classification
    event.kind      alert
    event.type      indicator
    event.category  ["authentication","threat"]
    event.action    root_login
    event.outcome   success
    event.severity  73
  </record>
</filter>
# =========================================================
# AUDIT LOGS
# =========================================================
<filter audit.log>
  @type record_transformer
  enable_ruby
  <record>
    # --- Extraction from the message ---
    # --- Layout expected: 
    # --- Audit: <event.code>|<user.name>|<user.role>|<source.ip>|<source.port>|<event.action>|<event.outcome>|<process.name>|<process.command_line>
    event.code            ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[0] : nil}
    user.name             ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[1] : nil}
    user.role             ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[2] : nil}
    source.ip             ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[3].split(":")[0] : nil}
    source.port           ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[3].split(":")[1] : nil}
    event.action          ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[4] : nil}
    event.outcome         ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[5] : nil}
    process.name          ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[6] : nil}
    process.command_line  ${record["message"].start_with?("Audit:") ? record["message"].sub(/^Audit: /, "").split("|")[7] : nil}
    
    # --- ECS event classification
    event.kind            event
    event.type            ["change","info"]
    event.category        ["configuration","iam"]
  </record>
</filter>


<filter audit.log>
  @type record_transformer
  enable_ruby true
  <record>
    event.kind ${ (record["process.command_line"].to_s =~ /(SET_LOGIN_POLICY|setminpasswordclasses|set_maxloginattempts_status|set_consec_maxlogincount|set_lockout_duration|setminpasswordlen|Authentication failed)/i) ? "alert" : "event" }
    event.severity ${ (record["process.command_line"].to_s =~ /(SET_LOGIN_POLICY|setminpasswordclasses|set_maxloginattempts_status|set_consec_maxlogincount|set_lockout_duration|setminpasswordlen|Authentication failed)/i) ? "73" : "21" }

  </record>
</filter>


# =========================================================
# RANSOMWARE DETECTION
# =========================================================
<filter rware.detect>
  @type record_transformer
  enable_ruby
  <record>
    # --- Extraction from the message ---
    # --- Layout expected: 
    # --- Ransomware monitoring detected suspicious data on volume <vv.name> [(vv_id)]. Note that [x] detections were muted since the previous alert on this VV.

    vv.name        ${record["message"] =~ /on volume (\S+) \d+/ ? $1 : nil}
    event.action   ransomware monitoring detected suspicious data on volume
    event.provider  ransomware.alert
    process.name   ransomware detection

    # --- ECS event classification
    event.kind     alert
    event.type     indicator
    event.severity 73
    event.category ["malware","threat"]
    rule.category  ransomware
  </record>
</filter>

<filter rware.snap>
  @type record_transformer 
  enable_ruby
  <record>
    # --- Extraction from the message ---
    # --- Layout expected:
    # --- On VV <vv.name> [(vv_id)], the system created a ransomware alert snapshot <vv.snap> [(snap_id)]
    vv.name        ${record["message"] =~ /On VV (\S+) \(/ ? $1 : nil}
    vv.snap        ${record["message"] =~ /snapshot (\S+) \(/ ? $1 : nil}
    event.action   the system created a ransomware alert snapshot
    process.name   ransomware detection
    event.provider  ransomware.alert

    # --- ECS event classification
    event.kind     alert
    event.type     indicator
    event.severity 73
    event.category ["malware","threat"]
    rule.category  ransomware
  </record>
</filter>

# =========================================================
# FAILED SSH LOGIN
# =========================================================
<filter ssh.login.fail>
  @type record_transformer
  enable_ruby
  <record>
    # --- Extraction from the message ---
    # --- Layout expected:
    # --- User <user.name> presented an incorrect password via ssh from <source.ip> .
    user.name       ${record["message"] =~ /User (?:invalid user\s+)?(\S+)/ ? $1 : nil}
    source.ip       ${record["message"] =~ /from ([\d\.]+)\b/ ? $1 : nil}
    event.reason    incorrect SSH password or key
    event.provider   ssh.authentication

    # --- ECS event classification
    event.kind      alert
    event.type      ["access","denied"]
    event.severity  47
    event.category  authentication
    rule.category   failed login
    event.outcome   failure
    process.name    ssh
  </record>
</filter>

# =========================================================
# AUTHENTICATION MESSAGES
# =========================================================


<filter cli.auth.success>
  @type record_transformer
  enable_ruby
  <record>
    # --- Extraction from the message ---
    # --- Layout expected:
    # --- [<process.name>] User <user.name> from <source.ip> was successfully authenticated using <auth.method>
    user.name       ${ (record["message"] =~ /\bUser\s+([^\s;]+)/i) ? $1 : nil }
    source.ip       ${ (record["message"] =~ /\bfrom\s+(\d{1,3}(?:\.\d{1,3}){3})\b/i) ? $1 : nil }
    process.name    ${ (record["message"] =~ /\[([^\]]+)\]\s*:/) ? $1 : nil }

    # --- ECS event classification
    event.kind      event
    event.type      allowed
    event.category  authentication
    event.action    login
    event.outcome   success
  </record>
</filter>

<filter cli.auth.logout>
  @type record_transformer
  enable_ruby
  <record>
    # --- Extraction from the message ---
    # --- Layout expected:
    # --- [<process.name>] User <user.name> from <source.ip> logged out: connected since YYYY-MM-DD HH:MM:SS XYZ
    user.name       ${ (record["message"] =~ /\bUser\s+([^\s;]+)/i) ? $1 : nil }
    source.ip       ${ (record["message"] =~ /\bfrom\s+(\d{1,3}(?:\.\d{1,3}){3})\b/i) ? $1 : nil }
    process.name    ${ (record["message"] =~ /\[([^\]]+)\]\s*:/) ? $1 : nil }

    # --- ECS event classification
    event.kind      event
    event.type      allowed
    event.category  authentication
    event.action    logout
    event.outcome   success
  </record>
</filter>

<filter user.locked>
  @type record_transformer
  enable_ruby
  <record>
    # --- Extraction from the message ---
    # --- Layout expected:
    # --- User account <user.name> has been locked due to multiple failed authentication attempts.
    user.name       ${ (record["message"] =~ /\baccount\s+([^\s;]+)/i) ? $1 : nil }

    # --- ECS event classification
    event.kind      alert
    event.type      denied
    event.severity  47
    event.category  authentication
    event.action    user locked
  </record>
</filter>

# =========================================================
# CLI COMMAND ERROR MESSAGES
# =========================================================

<filter cli.error>
  @type record_transformer
  enable_ruby true
  <record>

    # --- Extraction from the message ---
    # --- Layout expected:
    # --- {<user.name> <user.role> all {{0 8}} -1 <source.ip>:<source.port> session} Command: <process.command_line> Error: {<error.message>}.

    # First token inside the initial { ... } block
    user.name            ${ record["message"][/^\{(\S+)\s/, 1] }
    # Second token inside the initial { ... } block
    user.role            ${ record["message"][/^\{\S+\s+(\S+)/, 1] }
    # First IP found in the message (IPv4) BEFORE port separator
    source.ip            ${ record["message"][/(\d{1,3}(?:\.\d{1,3}){3}):\d+/, 1] }
    # Port immediately following the first IP
    source.port          ${ record["message"][/\d{1,3}(?:\.\d{1,3}){3}:(\d+)/, 1] }
    # Everything between "Command:" and "Error:"
    process.command_line ${ (s = record["message"][/Command:\s*(.*?)\s*Error:/m, 1]) && s.strip }
    # Everything after "Error:"
    message        ${ (s = record["message"][/Error:\s*(.*)\s*\z/m, 1]) && s.strip }

    # --- ECS event classification
    event.kind           event
    event.type           error
    event.outcome        failure
    event.category       configuration
    event.action         cli error
  </record>
</filter>

<filter cli.error>
  @type record_transformer
  enable_ruby true
  <record>
    event.kind           ${ (record["message"].to_s =~ /(until its retention time is expired)/i) ? "alert" : "event" }
    event.severity       ${ (record["message"].to_s =~ /(until its retention time is expired)/i) ? "73" : "21" }

  </record>
</filter>


# =========================================================
# OUTPUT: ECS JSON â€” per-host daily files (no compression)
# =========================================================
<match **>
  @type file
  @id out_ecs_file

  path /var/log/fluentd/ecs/${host.name}.%Y%m%d
  append true

  <format>
    @type json
    include_time_key true
    localtime true
  </format>

#  <inject>
#    tag_key fluent_tag
#    include_tag_key true
#  </inject>

  <buffer host.name,time>
    @type file
    path /var/log/hpe/buffer
    chunk_keys host.name,time
    timekey 1d
    timekey_use_utc true
    timekey_wait 10m
    flush_mode interval
    flush_interval 2s
    flush_at_shutdown true
  </buffer>
</match>